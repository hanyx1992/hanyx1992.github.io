<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>从 Notification.Name 看 Swift 如何优雅的解决 String 硬编码</title>
      <link href="/2018/08/05/RawRepresentable/"/>
      <url>/2018/08/05/RawRepresentable/</url>
      <content type="html"><![CDATA[<h2 id="前面"><a href="#前面" class="headerlink" title="前面"></a>前面</h2><p>初学 Swift 中相关 NSNotification 的代码时, 发现了之前熟悉的 name 参数的类型由 Objective-C 中的 NSString 变成了 Notification.Name 类型. 并不是我期望的 String 类型…这是怎么回事呢?</p><h2 id="Swift-中如何使用-Notification"><a href="#Swift-中如何使用-Notification" class="headerlink" title="Swift 中如何使用 Notification"></a>Swift 中如何使用 Notification</h2><p>那么, 在 Swift 中如何使用 Notification 呢, 以 post 为例. </p><pre><code class="swift">NotificationCenter.default.post(name: Notification.Name.UIApplicationDidFinishLaunching, object: nil)</code></pre><p>其中, <code>Notification.Name</code> 是可以省略的, 就变为了</p><pre><code class="swift">NotificationCenter.default.post(name: .UIApplicationDidFinishLaunching, object: nil)</code></pre><p>查看定义发现了 <code>UIApplicationDidFinishLaunching</code> 实际上是定义在结构体 <code>NSNotification.Name</code> 扩展(extension)中的的一个静态常量 (<code>static let</code>), 类型是 <code>NSNotification.Name</code> </p><pre><code class="Swift">extension NSNotification.Name {    @available(iOS 4.0, *)    public static let UIApplicationDidEnterBackground: NSNotification.Name    @available(iOS 4.0, *)    public static let UIApplicationWillEnterForeground: NSNotification.Name    public static let UIApplicationDidFinishLaunching: NSNotification.Name    ...}</code></pre><p>所以我们才可以省略前面的 <code>Notification.Name</code> 直接使用 <code>.UIApplicationDidFinishLaunching</code> (Notification.Name 是 NSNotification.Name 的别名)</p><p>那我们如果想自定义一个通知怎么办呢, 直接可以仿照系统的方式, 我们自己为其增加一个 <code>extension</code></p><pre><code class="swift">extension Notification.Name {    static let LoginStatusChanged = Notification.Name(&quot;LoginStatusChanged&quot;)}</code></pre><p>其中 <code>Notification.Name(&quot;LoginStatusChanged&quot;)</code> 是其初始化方法, 可查看文档说明, 使用时, 可直接</p><pre><code class="swift">NotificationCenter.default.post(name: .LoginStatusChanged, object: nil)</code></pre><p>因为这个通知 <code>LoginStatusChanged</code> 是定义在 <code>Notification.Name</code> 中的了, 所以也没必要在名称后面增加 Notification 等字样来表示这是一个通知了. 所以 Swift 中很多定义的名称都是非常简洁的.</p><h2 id="对比-Objective-C-中的使用"><a href="#对比-Objective-C-中的使用" class="headerlink" title="对比 Objective-C 中的使用"></a>对比 Objective-C 中的使用</h2><p>对比之前在 Objective-C 中的使用</p><p><code>[[NSNotificationCenter defaultCenter] postNotificationName:&quot;xxxxxxxxxx&quot; object:nil</code></p><p>这样是非常容易出错的, 查这样的错误经常也是非常费时费力的, 也让人看来是非常不优雅的, 所以我们经常会进行宏定义或者是常量来防止字符串硬编码的问题. </p><p>但这实际上也是会带来一些令人头疼的问题的:</p><ol><li>为了表明定义的字符串常量是一个通知名, 还要为其增加冗长的前缀或者是后缀</li><li>在开发中还经常会在代码补全中, 看到根本不和场合的一些常量名</li><li>通常为了使用方便和易于维护, 还会在将所有的通知定义在一个 xxDefine.h 的头文件中, 并在 pch 文件中引用, 此时如果增删或者修改了任意通知. 将会引起工程的全量重新编译. 也很是头疼.<br>…</li></ol><p>所以, Swift 这种使用方式可谓是十分优雅</p><h2 id="举一反三"><a href="#举一反三" class="headerlink" title="举一反三"></a>举一反三</h2><p>在开发中, 其实类似于 Notification 这种需要传递字符串的场景还有很多, 我们都可以使用这类使用方法进行优化.</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>假设有这样一个场景, 定义一个类 <code>EventReporter</code> 用来处理埋点请求.</p><pre><code class="swift">class EventReporter {    static let sharedInstance = EventReporter()    func reportEvent(_ eventId: String, withParams params: [String:Any]?) {        // 埋点上报逻辑    }}</code></pre><p>相信这样的场景是很多人都见过的, 其中 eventId 是我们埋点的事件的ID, 那么该如何使用类似 <code>Notification.Name</code> 的方式来优化这类场景呢?</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>从文档中看出 <code>Notification.Name</code> 实际上是遵从了一个协议 <code>RawRepresentable</code></p><blockquote><p>Overview</p></blockquote><blockquote><p>With a RawRepresentable type, you can switch back and forth between a custom type and an associated RawValue type without losing the value of the original RawRepresentable type. Using the raw value of a conforming type streamlines interoperation with Objective-C and legacy APIs and simplifies conformance to other protocols, such as Equatable, Comparable, and Hashable.</p></blockquote><blockquote><p>The RawRepresentable protocol is seen mainly in two categories of types: enumerations with raw value types and option sets.</p></blockquote><p>简单的说就是, 使用 <code>RawRepresentable</code> 类型, 可以在自定义类型和其关联的 <code>RawValue</code> 类型之间来回切换, 可简化与 Objective-C 和传统 API 的交互， 两类：具有原始值类型和选项集的枚举(OptionSet, 其实 Swift 中的选项集枚举就是集成自 <code>RawRepresentable</code> 这个 Protocol 实现的), 说白了. 就是用一个类型封装一下我们想要使用的类型比如说 String, 来方便交互.</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>使用起来很简单, 定义一个结构体来管理所有的埋点事件</p><pre><code class="swift">struct EventID: RawRepresentable {}</code></pre><p>根据编译器提示, 补全协议代码</p><pre><code class="swift">struct EventID: RawRepresentable {    typealias RawValue = String    var rawValue: String    init?(rawValue: String) {    }}</code></pre><p>从这就更容易看出其原理, 实际上内部的 <code>rawValue</code> 属性就是我们需要使用的 String 类型的事件名, 初始化方法传入该 String 对其赋值即可, 返回 <code>EventID</code> 类型的结构体</p><p>这里发现初始化方法返回的是一个 <code>Optional</code> 类型, 这样使用起来还需要解包, 不太方便, 可以看到 <code>Notification.Name</code> 的初始化方法返回并不是 <code>Optional</code>, 因为定义都是非常确定的事件名(通知名), 所以此处没什么必要使用 <code>Optional</code>, 去掉 <code>?</code> 即可</p><pre><code class="swift">struct EventID: RawRepresentable {    typealias RawValue = String    var rawValue: String    init(rawValue: String) {        self.rawValue = rawValue    }}</code></pre><p>那么, 我们的上报类的代码可以修改如下, 这里还可以给 <code>params</code> 一个默认值, 这样如果没有参数时, 可以只传递 <code>eventId</code> 一个参数即可.</p><pre><code class="swift">class EventReporter {    static let sharedInstance = EventReporter()    func reportEvent(_ eventId: EventID, withParams params: [String:Any]? = nil) {        let event = eventId.rawValue        // 埋点逻辑    }}</code></pre><p>最后, 定义一个埋点事件看看吧~</p><pre><code class="swift">extension EventID {    static let LoginPageExposure = EventID(rawValue: &quot;login_page_exposure&quot;)}</code></pre><p>那么使用的时候, </p><pre><code class="swift">EventReporter.sharedInstance.reportEvent(.LoginPageExposure)</code></pre><p>当我们打出 <code>.</code> 的时候, 代码不全就已经将 <code>LoginPageExposure</code> 提示给我们了.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用这种方式优化代码, 不仅可以让代码意图容易理解, 使用也更加简单不会出错. 而且也不会使得 <code>LoginPageExposure</code> 事件名在不想要出现的时候被代码不全功能强行弹出来.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://developer.apple.com/documentation/foundation/nsnotification/name" target="_blank" rel="noopener">NSNotification.Name</a></li><li><a href="https://developer.apple.com/documentation/swift/rawrepresentable" target="_blank" rel="noopener">RawRepresentable</a></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>SVN 迁移至 Git 完整记录</title>
      <link href="/2018/07/26/svn-to-git/"/>
      <url>/2018/07/26/svn-to-git/</url>
      <content type="html"><![CDATA[<h1 id="Git-万岁"><a href="#Git-万岁" class="headerlink" title="Git 万岁"></a>Git 万岁</h1><p>为什么在 8102 年还在用 SVN 就不要问我了..总之 Git 万岁…</p><h2 id="Clone"><a href="#Clone" class="headerlink" title="Clone"></a>Clone</h2><h3 id="完整迁移"><a href="#完整迁移" class="headerlink" title="完整迁移"></a>完整迁移</h3><p>Git 提供了从 SVN 迁移的工具命令 <code>git svn clone</code>, 可在 SVN 中, 是以目录形式, trunk, branches, tags 来存储的, 如何保留呢?</p><p>如果你的 SVN 中都是以标准形式存储即 trunk 中为主干, branches 中为所有分支, 则可以直接使用参数 <code>-s</code>, 否则则需要自己指定对应的目录.</p><p>比如, 我们的项目中, 分支是以这种目录结构存储的</p><pre><code>branches  |  |- develop  |     |  |     |- dev1_分支  |     |- dev2_分支  |  |- personal  |     |  |     |- xxx1_分支  |     |- xxx2_分支</code></pre><p>则, 我需要使用多个 –branches 命令来指定对应的两个分支目录</p><pre><code>--branches=branches/develop --branches=branches/personal</code></pre><p>用来指定我们的两个分支目录 <code>branches/develop</code> 和 <code>branches/personal</code>, 这里需要特别注意的是 <strong>指定的分支目录应该是分支所在文件夹的上一级文件夹, 比如此处目录是 branches/develop, 而不应该是 branches/develop/dev1_分支</strong></p><p>在我们项目中, trunk 和 tags 都是按照标准形式存储的, 所以只要再加一个命令 <code>-s</code> 即可, 相当于补充了 <code>--trunk=trunk --tags=tags --branches=branches</code> 只不过我们这里 branches 里面没有分支了. 这个没关系~</p><p>所以 clone 的完整命令如下</p><pre><code>git svn clone http://xxxx/xxxx/xxxx/xxxx \    --branches=branches/develop \    --branches=branches/personal \    -s</code></pre><h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><p>这样其实已经是没问题的了, 但是我们还希望在 SVN 上提交的用户信息也能顺利的迁移到 Git 中来, 因为 SVN 中提交信息只有用户名, 而 Git 则需要用户名和邮箱两个信息, 所以需要制定名称对应名称和邮箱的映射关系.</p><p>这里我使用文件的方式, 在本地创建好文件夹, 准备一会进行 clone, 在此文件夹中, 我创建了 name.txt 来进行名称的映射, 内容格式如下:</p><pre><code>yuanxuhan = yuanxuhan &lt;yuanxuhan@xxx.com&gt;xxx = xxx &lt;xxx@xxx.com&gt;</code></pre><p>需要注意的是, <strong>如果想要进行用户信息的迁移, 则需要把在 SVN 中提交过的所有用户信息都要进行对应, 否则会报错</strong></p><p>然后在 clone 的命令中, 增加 <code>--authors-file=name.txt</code> 来指定映射信息文件</p><blockquote><p>为了获得 SVN 使用的作者名字列表，可以运行这个：</p><p>svn log –xml | grep author | sort -u | \<br>  perl -pe ‘s/.<em>&gt;(.</em>?)&lt;.*/$1 = /‘</p></blockquote><h3 id="完整命令"><a href="#完整命令" class="headerlink" title="完整命令"></a>完整命令</h3><pre><code>git svn clone http://xxxx/xxxx/xxxx/xxxx \    --authors-file=users.txt \    --branches=branches/develop \    --branches=branches/personal \    -s</code></pre><p>等待 clone 完毕</p><h2 id="整理"><a href="#整理" class="headerlink" title="整理"></a>整理</h2><h3 id="保留分支"><a href="#保留分支" class="headerlink" title="保留分支"></a>保留分支</h3><p>clone 完毕之后, 使用 <code>git branch</code>, 发现只有一个 master 分支, 其实是 Git 将 SVN 的 trunk 转换成了 master, <strong>而其他的 branches 则变成了 git 的 remote 分支 origin/xxx, 以远端分支的形式存在了本地</strong>, 可以使用命令 <code>git branch -r</code> 检查分支转换的没毛病~</p><p>这里我们要保留所有分支信息. 所以要对所有分支进行 <code>checkout -b</code>, 按照自己 Git 的一些规范保留分支即可. 如</p><p><code>git checkout -b feature/3.0.1 origin/dev1_分支</code></p><p>如果不需要整理分支名等需求, 也可以使用下面提供的直接移动文件夹的操作</p><h3 id="保留-tag"><a href="#保留-tag" class="headerlink" title="保留 tag"></a>保留 tag</h3><p>我们这个项目比较小, 还没有 tag, 如果有的话可以参照文档提供的方法(未试过)</p><blockquote><p>为了将标签变为合适的 Git 标签，运行</p></blockquote><pre><code>$ cp -Rf .git/refs/remotes/origin/tags/* .git/refs/tags/$ rm -Rf .git/refs/remotes/origin/tags</code></pre><blockquote><p>这会使原来在 remotes/origin/tags/ 里的远程分支引用变成真正的（轻量）标签。</p><p>接下来，将 refs/remotes 下剩余的引用移动为本地分支：</p></blockquote><pre><code>$ cp -Rf .git/refs/remotes/* .git/refs/heads/$ rm -Rf .git/refs/remotes</code></pre><h3 id="删除远端信息"><a href="#删除远端信息" class="headerlink" title="删除远端信息"></a>删除远端信息</h3><p>将所有分支都整理完毕后, 使用 <code>git branch</code> 检查确认无误之后, 删除 origin 的信息即可,</p><pre><code>git remote rm origin</code></pre><p>或者</p><pre><code>rm -Rf .git/refs/remotes</code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="钩子"><a href="#钩子" class="headerlink" title="钩子"></a>钩子</h3><p>整理之后可以进行配置 Git hook 等等其他信息, 这个使用的是我们小组的规范脚本, 不方便记录.</p><h3 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h3><blockquote><p><a href="https://www.gitignore.io" target="_blank" rel="noopener">https://www.gitignore.io</a></p></blockquote><p>可以在这个<a href="https://www.gitignore.io" target="_blank" rel="noopener">网址</a> 输入三个关键字, <code>Swift</code>, <code>Xcode</code>, <code>macOS</code> 会自动组合好 .gitignore 文件, 存放到 Git 仓库目录中并提交.</p><h3 id="新增-tag"><a href="#新增-tag" class="headerlink" title="新增 tag"></a>新增 tag</h3><p>之前 SVN 管理的比较松散, 转换之后, 应该在 App Connet 中, 找到上架包的版本号和 build 号, 在持续集成平台中查找该版本的对应 build, 查看最后一个 commit, 并在该 commit 处增加 tag, 并且分支可以删掉了, 以便线上 bug 的定位和解决.</p><h2 id="关联远端"><a href="#关联远端" class="headerlink" title="关联远端"></a>关联远端</h2><p>在 Git 服务器创建好新的仓库后, 关联一下远端服务器</p><pre><code>git remote add origin http://xxx/xxx.git</code></pre><p>推送所有分支</p><pre><code>git push origin --all</code></pre><p>推送所有标签</p><pre><code>git push origin --tags</code></pre><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://git-scm.com/book/zh/v2/Git-%E4%B8%8E%E5%85%B6%E4%BB%96%E7%B3%BB%E7%BB%9F-%E8%BF%81%E7%A7%BB%E5%88%B0-Git" target="_blank" rel="noopener">9.2 Git 与其他系统 - 迁移到 Git</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>基于 iOS 11 Vision 的人脸识别和特征点提取的表情包模仿功能的实践</title>
      <link href="/2018/07/15/vision-demo/"/>
      <url>/2018/07/15/vision-demo/</url>
      <content type="html"><![CDATA[<h1 id="前面"><a href="#前面" class="headerlink" title="前面"></a>前面</h1><p>想起来去年在上家公司做的个小 Demo, 记录一下吧, 背景是当时食堂空间承受不住了, 大佬们组织了一场黑客马拉松, 实现摇号吃饭, 各个部门的大佬前后端开发设计师产品都组队参赛, 我当时所在的部门都在忙着产品上线没人愿意参加, 介于我逗比的潜质, 独自一人邀请了一个产品小伙伴组成了唯一一个只有两个人参赛的队伍…大概是花了2天时间完成…</p><p><strong>感谢我的产品小伙伴 @刘海滨, 点子都是他想的.</strong></p><p>初衷是, 每日推荐一个表情包, 然后大家进行模仿自拍, 匹配相似度. 进行排队吃饭. 大致效果图如下…惨不忍睹…</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/21/1607730eeb227377?w=375&amp;h=667&amp;f=gif&amp;s=2584477" alt="效果图"></p><h1 id="功能点"><a href="#功能点" class="headerlink" title="功能点"></a>功能点</h1><ul><li>AVFoundation 实现自拍的相机功能</li><li>基于 Vision 进行实时人脸追踪</li><li>拍照后基于 Vision 进行人脸特征点提取, 并且展示出来</li><li>表情包的特征点和自拍的特征点进行相似度匹配</li><li>对自拍进行剪裁, 表情包中的文字添加, 人脸磨皮美颜, 完成表情包制作, 分享.</li></ul><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="搭建项目"><a href="#搭建项目" class="headerlink" title="搭建项目"></a>搭建项目</h2><p>因为要使用 Vision 框架所以只能支持 iOS 11 及以上版本.</p><p>本来最开始是希望可以做完整的, 但是时间太少了, 只做了上面提到的这些功能, 功能少, 所以结构非常简单, 在”我”的和”我们的”两个标签下面内容几乎没有….</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/25/1608d0964120a1b7?w=1024&amp;h=768&amp;f=jpeg&amp;s=349406" alt="项目结构图"></p><p>那后面就只说一下核心功能的结构吧.</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/25/1608d09b666ef188?w=1024&amp;h=768&amp;f=jpeg&amp;s=142428" alt="核心功能结构"></p><p>从下至上, 短时间快速实现的简单的结构, 可能考虑不充分导致不是特别理想.</p><ul><li>人脸模型 : 封装 Vison 的人脸模型, 方便自己使用</li><li>人脸工具类 : 提供根据图片的人脸检测和特征点提取等方法</li><li>特征比较 : 提供两个特征的相似度比较</li><li>相机工具类 : 完整的处理相机的逻辑一直到拍好一张照片交给控制器</li><li>视图控制器 : 初始化相机工具类, 控制相机会话的启动和停止, 以及得到照片的得分和保存.</li></ul><p>下面是各个核心功能的一些实现过程.</p><h2 id="自定义相机"><a href="#自定义相机" class="headerlink" title="自定义相机"></a>自定义相机</h2><p>自定义相机这部分.走了一点弯路, 因为只支持 iOS 11, 原来熟悉的到处可以 Copy 的 AVFoundation 代码有一些 API 分别在 iOS 10 和 iOS 11 中被弃用了…我有看不惯弃用 API 的警告, 于是走上了填坑之路…</p><p>首先 <code>XYCaptureController.m</code> 为自拍的视图控制器, 我将相机的相关处理封装提取出来 <code>XYCaptureHelper.m</code> 好处是</p><ul><li>控制器逻辑简单, 算上空行也才100多行代码;</li><li>如果别的项目还需要相机可以直接拽过去稍微修改一下就能用了.</li></ul><p>在 <code>XYCaptureHelper.h</code> 中暴露最核心的方法是创建相机会话</p><pre><code class="objc">/**在View上创建扫描会话*/- (void)setupCaptureSessionDisplayOnView:(UIView *)captureView;</code></pre><p>方法实现先校验了一下权限, 感兴趣的可以看 <code>XYAuthUtil</code> 对权限和跳转设置界面的简单封装.</p><p>校验权限后, 创建相机会话分为三步</p><pre><code class="objc">/**创建相机扫描视图*/- (void)setupCaptureOnView:(UIView *)captureView {    //  弱引用父视图, 方便布局等其他控制    self.captureView = captureView;    //  创建相机会话    [self setupCaptureSession];    //  创建相机预览层    [self setupCaptureDisplay];    //  创建人脸预览层    [self setupFacePreview   ];}</code></pre><h3 id="创建相机会话"><a href="#创建相机会话" class="headerlink" title="创建相机会话"></a>创建相机会话</h3><pre><code class="objc">- (void)setupCaptureSession {    _captureQueue = dispatch_queue_create(&quot;com.hanyx.PassionForEating.Capture&quot;, DISPATCH_QUEUE_SERIAL);    self.session = [[AVCaptureSession alloc] init];    self.session.sessionPreset = AVCaptureSessionPresetPhoto;    self.device = [self cameraWithPostion:AVCaptureDevicePositionFront];    self.input = [[AVCaptureDeviceInput alloc] initWithDevice:self.device error:nil];    AVCaptureVideoDataOutput *dataOutput = [[AVCaptureVideoDataOutput alloc] init];    [dataOutput setAlwaysDiscardsLateVideoFrames:YES];    [dataOutput setVideoSettings:@{(id)kCVPixelBufferPixelFormatTypeKey:@(kCVPixelFormatType_32BGRA)}];    [dataOutput setSampleBufferDelegate:self queue:_captureQueue];    self.dataOutput = dataOutput;    self.imageOutput = [[AVCapturePhotoOutput alloc] init];    if ([self.session canAddInput:self.input]) {        [self.session addInput:self.input];    }    if ([self.session canAddOutput:dataOutput]) {        [self.session addOutput:dataOutput];    }    if ([self.session canAddOutput:self.imageOutput]) {        [self.session addOutput:self.imageOutput];    }    AVCaptureConnection *connection = [dataOutput.connections firstObject];    [connection setVideoOrientation:AVCaptureVideoOrientationPortrait];</code></pre><p>其实就是主流的写法, 获取相机设备, 根据设备创建输入, 输出对象, 都添加到相机会话中, 比较重要的是, 实现了 <code>AVCaptureVideoDataOutputSampleBufferDelegate</code> 代理, 来获得到相机捕获的缓冲帧信息.</p><p>关于 iOS 11 第一处不同是 <code>imageOutput</code> 之前我们习惯去使用 <code>AVCaptureStillImageOutput</code> 对象来获取相机拍摄的高清照片, 但是这个类在 iOS 10 中被弃用了, 需要使用 <code>AVCapturePhotoOutput</code> 对象代替.</p><h3 id="创建相机预览层"><a href="#创建相机预览层" class="headerlink" title="创建相机预览层"></a>创建相机预览层</h3><pre><code class="objc">- (void)setupCaptureDisplay {    //  预览层的生成    self.previewLayer = [[AVCaptureVideoPreviewLayer alloc] initWithSession:self.session];    self.previewLayer.videoGravity = AVLayerVideoGravityResizeAspectFill;    [self.captureView.layer insertSublayer:self.previewLayer atIndex:0];}</code></pre><p>创建预览层主要要设置的就是显示的缩放模式, 和 UIView 的 contentMode 很相似提供了三种, 非常简单, 一看就明白了.我这里使用 <code>AVLayerVideoGravityResizeAspectFill</code> 保持缩放比例来填充视图, 防止出现黑边的情况. 因为在父视图中, 可能存在其他视图, 比如拍照按钮等等, 所以预览图层我这里插入到最底层</p><h3 id="创建人脸预览层"><a href="#创建人脸预览层" class="headerlink" title="创建人脸预览层"></a>创建人脸预览层</h3><pre><code class="objc">- (void)setupFacePreview {    CAShapeLayer *faceShape = [[CAShapeLayer alloc] init];    faceShape.fillColor     = [UIColor clearColor].CGColor;    faceShape.strokeColor   = [UIColor colorNamed:COLOR_Main].CGColor;    faceShape.lineWidth     = 1;    [self.captureView.layer addSublayer:faceShape];    self.faceShapeLayer     = faceShape;}</code></pre><p>人脸预览层我这里使用 <code>CAShapeLayer</code> 指定了一个橙色的颜色. 用来框柱人脸区域.</p><h3 id="会话控制"><a href="#会话控制" class="headerlink" title="会话控制"></a>会话控制</h3><p>可以发现. 预览层我都没有指定 <code>frame</code> 可能由于各种问题, 获取父视图的 <code>frame</code><br>可能并不如预期, 所以, 我在开始回话的地方, 进行了 <code>frame</code> 的获取和对预览层 <code>frame</code> 的设置</p><pre><code class="objc">- (void)startRunning {    [self.session startRunning];    dispatch_async(dispatch_get_main_queue(), ^{        //  计算各个视图的尺寸        self.captureFrame = self.captureView.frame;    });}- (void)stopRunning {    [self.session stopRunning];}- (void)setCaptureFrame:(CGRect)captureFrame {    if (CGRectEqualToRect(_captureFrame, captureFrame)) {        return ;    }    _captureFrame = captureFrame;    CGRect bounds = (CGRect){0, 0, captureFrame.size.width, captureFrame.size.height};    self.previewLayer.frame = bounds;    self.faceShapeLayer.frame = bounds;}</code></pre><p>这个地方我创建了 <code>self.captureFrame</code> 的属性, 而不是直接使用 <code>self.captureView.frame</code> 是因为在捕获的过程中, 很多操作可能都需要该 <code>frame</code> 中的信息, 但是 <code>UIView</code> 的 <code>frame</code> 实际上只允许在主线程调用. 所以这里使用属性方便了操作.</p><h3 id="实时缓冲帧的获取"><a href="#实时缓冲帧的获取" class="headerlink" title="实时缓冲帧的获取"></a>实时缓冲帧的获取</h3><p>之前已经说过, 实现了 <code>AVCaptureVideoDataOutputSampleBufferDelegate</code> 代理, 来获得到相机捕获的缓冲帧信息.实现方法</p><pre><code class="objc">- (void)captureOutput:(AVCaptureOutput *)captureOutput didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection {}</code></pre><p>可以根据 <code>CMSampleBufferRef</code> 来获取到缓冲帧的图片, 图片是低质量的.</p><h3 id="拍照"><a href="#拍照" class="headerlink" title="拍照"></a>拍照</h3><p>因为照片输出对象换成了新的 <code>AVCapturePhotoOutput</code> 所以拍照部分也有所变化,</p><pre><code class="objc">- (void)captureWithSender:(UIButton *)sender {    //  震动反馈    [self.taptic impactOccurred];    AVCaptureConnection *con = [self.imageOutput connectionWithMediaType:AVMediaTypeVideo];    UIDeviceOrientation curDeviceOrientation = [[UIDevice currentDevice] orientation];    AVCaptureVideoOrientation avcaptureOrientation = [self avOrientationForDeviceOrientation:curDeviceOrientation];    [con setVideoOrientation:avcaptureOrientation];    [self.imageOutput capturePhotoWithSettings:[AVCapturePhotoSettings photoSettings] delegate:self];}</code></pre><p>获取连接, 提前设置了方向, 防止照出来的图片可能会旋转90°的问题. 拍照的过程也有变换, 原来使用 <code>AVCaptureStillImageOutput</code> 的时候很方便通过 <code>block</code> 的方式获取原图, 现在需要使用代理. 实现 <code>AVCapturePhotoCaptureDelegate</code> 代理, 当拍照成功时, 会调用如下方法来获取高清图片</p><pre><code class="objc">- (void)captureOutput:(AVCapturePhotoOutput *)output didFinishProcessingPhoto:(nonnull AVCapturePhoto *)photo error:(nullable NSError *)error {    NSData *imgData = photo.fileDataRepresentation;    UIImage *img = [UIImage imageWithData:imgData];}</code></pre><p>需要多说一句的是, <code>AVCapturePhotoSettings</code> 我添加了一个属性, 通过懒加载的方式初始化来进行使用, 可是在第二次拍摄的时候就会导致崩溃, 因为 <code>AVCapturePhotoSettings</code> 对象不能重复使用, 所以我这里每次拍照的时候创建了一个对象.</p><p>关于自定义相机大概内容就是这么多, 接下来看如何使用 Vision 来对捕获到的缓冲帧进行人脸追踪.</p><h2 id="人脸追踪"><a href="#人脸追踪" class="headerlink" title="人脸追踪"></a>人脸追踪</h2><h3 id="如何根据一张照片获取人脸位置"><a href="#如何根据一张照片获取人脸位置" class="headerlink" title="如何根据一张照片获取人脸位置?"></a>如何根据一张照片获取人脸位置?</h3><p>我在 <code>XYFaceHelper</code> 中封装了如下方法, 根据图片 <code>CIImage</code> 获取一个人脸矩形区域 <code>CGRect</code></p><pre><code class="objc">/** 人脸矩形区域检测 */+ (void)detectFaceRectWithImage:(CIImage *)image completion:(void(^)(CGRect faceRect))completion;</code></pre><p>内部实现其实就是调用了 Vision 框架, 简单看一下如何使用 Vision 框架.</p><pre><code class="objc">/** 人脸矩形区域检测 */+ (void)detectFaceRectWithImage:(CIImage *)image completion:(void (^)(CGRect faceRect))completion {    if (!image || !completion) { return ; }    CGFloat imgW = image.extent.size.width;    CGFloat imgH = image.extent.size.height;    VNImageRequestHandler *vnHandler = [[VNImageRequestHandler alloc] initWithCIImage:image orientation:kCGImagePropertyOrientationUp options:@{}];    VNDetectFaceRectanglesRequest *request = [[VNDetectFaceRectanglesRequest alloc] initWithCompletionHandler:^(VNRequest * _Nonnull request, NSError * _Nullable error) {        NSArray *results = request.results;        if (!results.count) {            completion(CGRectZero);            return ;        }        //  获取结果        VNFaceObservation *item = [self biggestObservationInArray:results];        CGRect rect = item.boundingBox;        //  根据比例偏移量计算在 View 中的位置        CGFloat x = rect.origin.x * imgW;        CGFloat y = rect.origin.y * imgH;        CGFloat w = rect.size.width * imgW;        CGFloat h = rect.size.height * imgH;        //  返回结果, 坐标系转换, y值翻转        CGRect result = CGRectMake(x, imgH - y - h, w, h);        completion(result);    }];    [vnHandler performRequests:@[request] error:nil];}</code></pre><p>关于使用的逻辑很清晰:</p><ul><li>使用 <code>CIImage</code> 创建一个 <code>VNImageRequestHandler</code> 图片请求处理器</li><li>创建 <code>VNDetectFaceRectanglesRequest</code> 人脸矩形区域识别的请求</li><li>处理器 处理 请求.</li></ul><p>关于处理完成的 Block:</p><p>Vison 返回的结果是一个数组, 因为图片中可能会有多个人脸. 那么基于我们的需求, 我这里取人脸区域面积最大的人脸进行处理. 处理时, 有两点需要注意:</p><ol><li><p>Vison 的识别结果 <code>VNFaceObservation</code> 所返回的矩形区域实际上值都是相对于图片宽高的比例, 假设图片宽 1000 像素, 人脸区域宽 100 像素, 则返回的 <code>CGRect</code> 中 width 其实为 <strong>0.1</strong>, 我们需要乘以图片的宽 1000 才能得到人脸区域的宽 100.</p></li><li><p><code>CoreImage</code> 的坐标系和 <code>UIKit</code> 中的坐标系是不一样的, 相信使用过 <code>CoreImage</code> 的同学都了解, 在 <code>UIKit</code> 中, 坐标原点是在屏幕<strong>左上角</strong>, 在 <code>CoreImage</code> 中, 坐标原点是在屏幕<strong>左下角</strong>, 我这里希望坐标转换成熟悉的 <code>UIKit</code> 中的坐标系. 转换关系如图:</p></li></ol><p><img src="https://user-gold-cdn.xitu.io/2017/12/25/1608d0e2abf60b9f?w=1024&amp;h=768&amp;f=jpeg&amp;s=118246" alt="坐标转换"></p><p>简单来说, 只有 Y 坐标需要转换, 记一个公式也可以 : <code>Y(UIKit) = 总高 - Y(CoreImage) - 区域高</code></p><p>这样已经封装好一个根据一张图片返回人脸矩形区域的方法了.非常简单. 那么我们只要获取到摄像头捕捉的图片, 然后调用刚刚封装好的方法就可以了.</p><h3 id="获取缓冲帧照片"><a href="#获取缓冲帧照片" class="headerlink" title="获取缓冲帧照片"></a>获取缓冲帧照片</h3><p>因为 Vision 框架需要的图片类型是 <code>CIImage</code>, 所以我这刚刚说的代理方法中, 直接通过缓冲帧获得一个 <code>CIImage</code> 的对象.</p><pre><code class="objc">- (void)captureOutput:(AVCaptureOutput *)captureOutput didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection {    CVPixelBufferRef pixelBuffer = (CVPixelBufferRef)CMSampleBufferGetImageBuffer(sampleBuffer);    CIImage *ciImage = [CIImage imageWithCVPixelBuffer:pixelBuffer];    ...    [XYFaceHelper detectFaceRectWithImage:image completion:^(CGRect faceRect) {        ...    }];}</code></pre><h3 id="实时显示人脸框"><a href="#实时显示人脸框" class="headerlink" title="实时显示人脸框"></a>实时显示人脸框</h3><p>获取到人脸的区域 <code>CGRect</code> 之后就非常简单了. 改变之前创建的人脸预览层 <code>CGShapeLayer</code> 的 <code>path</code> 即可.</p><p>因为前置摄像头看见的我们是镜子中的我们, 和现实中的我们是镜像关系, 所以相机捕获到照片后, 会做一个水平翻转, 所以</p><pre><code class="objc">        //  人脸检测        [XYFaceHelper detectFaceRectWithImage:image completion:^(CGRect faceRect) {            CGPathRef path;            if (faceRect.size.height &amp;&amp; faceRect.size.width) {                //  根据比例偏移量计算在 View 中的位置                CGFloat x = faceRect.origin.x - offsetX;                CGFloat y = faceRect.origin.y - offsetY;                CGFloat w = faceRect.size.width;                CGFloat h = faceRect.size.height;                //  坐标系转换, 自拍 x 值翻转                CGRect drawRect = CGRectMake(viewW - x - w, y, w, h);                path = [UIBezierPath bezierPathWithRoundedRect:drawRect cornerRadius:7].CGPath;            } else {                path = nil;            }            //  绘制人脸框框            dispatch_sync(dispatch_get_main_queue(), ^{                self.faceShapeLayer.path = path;            });        }];</code></pre><h2 id="特征点提取"><a href="#特征点提取" class="headerlink" title="特征点提取"></a>特征点提取</h2><h2 id="相似度匹配"><a href="#相似度匹配" class="headerlink" title="相似度匹配"></a>相似度匹配</h2><h2 id="表情包制作"><a href="#表情包制作" class="headerlink" title="表情包制作"></a>表情包制作</h2>]]></content>
      
      
    </entry>
    
    <entry>
      <title>GitHub 个人博客搭建</title>
      <link href="/2018/05/02/helloworld/"/>
      <url>/2018/05/02/helloworld/</url>
      <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p><a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">下载 node.js</a></p><h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p><a href="https://hexo.io/docs/" target="_blank" rel="noopener">安装 hexo</a></p><p>执行如下命令</p><pre><code>npm install -g hexo-cli</code></pre><p>我这里安装报错了. 原因是安装全局模块没有权限</p><p><a href="https://blog.csdn.net/gentlycare/article/details/51279529" target="_blank" rel="noopener">参照这个解决方案</a></p><p>选择了修改全局安装路径的方法:</p><p>创建一个默认的安装路径</p><pre><code>mkdir ~/.npm-global</code></pre><p>修改npm默认配置</p><pre><code>npm config set prefix &#39;~/.npm-global&#39;</code></pre><p>配置环境变量, 由于我使用的是 <code>zsh</code>, 所以编辑</p><pre><code>vi ~/.zshrc</code></pre><p>增加一行</p><pre><code>export PATH=~/.npm-global/bin:$PATH</code></pre><p>之后</p><pre><code>source ~/.zshrc</code></pre><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="GitHub-配置仓库"><a href="#GitHub-配置仓库" class="headerlink" title="GitHub 配置仓库"></a>GitHub 配置仓库</h3><p>必须使用 <code>username.github.io</code> 的命名, 如我的 <code>hanyx1992.github.io</code></p><h3 id="本地"><a href="#本地" class="headerlink" title="本地"></a>本地</h3><p>在本地选择安稳的地方创建文件夹作为自己的博客工程, 在目录中执行如下命令来进行初始化</p><pre><code>hexo initnpm installnpm install hexo-deployer-git --save</code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><p>我选择了<a href="https://material.viosey.com/docs/#/start" target="_blank" rel="noopener">Material</a></p><ol><li><p><a href="https://github.com/viosey/hexo-theme-material/releases" target="_blank" rel="noopener">下载了最新的包</a>并解压缩.</p></li><li><p>将整个文件夹命名为 <code>material</code></p></li><li><p>移动到工程目录 <code>博客/themes/</code> 中</p></li><li><p>将主题配置 <code>博客/themes/material/_config.template.yml</code> 改名为 <code>_config.yml</code> 以便生效</p></li><li><p>修改博客配置 <code>博客/_config.yml</code> 中的 <code>theme</code> 主题字段值为 <code>material</code></p></li></ol><p><a href="https://material.viosey.com/docs/#/start" target="_blank" rel="noopener">主题配置可参照 Material 详细文档</a></p><h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><p>修改博客配置 <code>博客/_config.yml</code> 中来关联 GitHub 仓库</p><pre><code>deploy:  type: git  repository: https://github.com/hanyx1992/hanyx1992.github.io.git  branch: master</code></pre><p><a href="https://hexo.io/docs/configuration.html" target="_blank" rel="noopener">其他配置可参照 Hexo 详细文档</a></p><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>hexo 自带的代码高亮几乎没有什么效果, 我这里按照这篇文章的进行了配置 <a href="http://jumpbyte.cn/2016/07/02/use-and-install-prettify/" target="_blank" rel="noopener">为hexo博客加入prettify高亮插件</a></p><p>我和原文作者用的不是一个主题, 不过基本没有什么问题, 看原文即可, 我这里整理一下最终执行的步骤如下:</p><h4 id="禁用默认高亮插件"><a href="#禁用默认高亮插件" class="headerlink" title="禁用默认高亮插件"></a>禁用默认高亮插件</h4><p>在 <code>博客/_config.yml</code> 中将 highlight 插件禁用, 找到如下部分都改成 false 即可</p><pre><code>highlight:  enable: false  line_number: false  auto_detect: false  tab_replace:</code></pre><h4 id="引用-Prettify-插件"><a href="#引用-Prettify-插件" class="headerlink" title="引用 Prettify 插件"></a>引用 Prettify 插件</h4><p><a href="https://github.com/google/code-prettify" target="_blank" rel="noopener">Google-code-prettify</a>, 在这下载源码, 将 src 目录(其中有一堆 lang-xxx.js, 可以看到有很多语言, 但是并没有 Objective-C 相关的文件, 可见对其应该支持的不太好)拷贝到 <code>博客/source/plugins</code>, 并将 src 改名为 prettify, 这里 plugins 是自己创建的目录, 方便以后增加插件, 都可以放到这里面.</p><h4 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h4><p><a href="https://github.com/jmblog/color-themes-for-google-code-prettify/blob/master/dist/themes.zip" target="_blank" rel="noopener">点击这里下载多种主题</a></p><p>解压缩之后, 将主题拷贝到 prettify 目录中, 将文件夹命名为 themes, <a href="https://jmblog.github.io/color-themes-for-google-code-prettify/" target="_blank" rel="noopener">可以在这看各种主题的效果预览</a></p><h4 id="配置高亮风格"><a href="#配置高亮风格" class="headerlink" title="配置高亮风格"></a>配置高亮风格</h4><p>在 <code>博客/_config.yml</code> 中找到一个好位置, 增加如下配置, 我选择在 hightlight 附近.</p><pre><code>prettify:  enable: true  theme: &quot;tranquil-heart&quot;</code></pre><p>theme 为选择的样式 css 的文件名, 不用加后缀, 我这里随便选择了 tranquil-heart .</p><p>并且找到 <code>skip_render</code>, 修改配置:</p><pre><code>skip_render:  - &quot;plugins/**&quot; #自己配置插件, 跳过渲染</code></pre><h4 id="引入代码高亮插件"><a href="#引入代码高亮插件" class="headerlink" title="引入代码高亮插件"></a>引入代码高亮插件</h4><p>编辑主题(我这里是 Material) <code>博客/themes/material/layout/_partial/</code> 下的 head.ejs 和 footer.ejs, 不同主题可能命名不一样.</p><p>head.ejs 最下面(<code>&lt;/head&gt;</code>)之前插入</p><pre><code>&lt;% if (config.prettify.enable){ %&gt;      &lt;!-- prettify代码高亮主题css引入 --&gt;      &lt;link href=&quot;/plugins/prettify/themes/&lt;%= config.prettify.theme %&gt;.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;% } %&gt;</code></pre><p>footer.ejs 最下面(<code>&lt;/footer&gt;</code>)之前插入</p><pre><code>&lt;!-- prettify代码高亮js引入 --&gt;&lt;% if (config.prettify.enable){ %&gt;    &lt;script src=&quot;/plugins/prettify/prettify.js&quot;&gt;&lt;/script&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        $(window).load(function(){            $(&#39;pre&#39;).addClass(&#39;prettyprint linenums&#39;).attr(&#39;style&#39;, &#39;overflow:auto;&#39;);            prettyPrint();        });    &lt;/script&gt;&lt;%}%&gt;</code></pre><p>之后可以通过 <code>hexo clean</code> 命令清除缓存, 之后再部署预览.</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><pre><code>//生成文件hexo g//本地服务预览hexo s//部署到GitHubhexo d</code></pre><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://zhuanlan.zhihu.com/p/32957389" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32957389</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>iOS 0行代码实现 TableView 无数据时展示占位视图</title>
      <link href="/2017/12/21/tableview-nodata-view/"/>
      <url>/2017/12/21/tableview-nodata-view/</url>
      <content type="html"><![CDATA[<h2 id="前面"><a href="#前面" class="headerlink" title="前面"></a>前面</h2><p>目前项目功能做的差不多了. 需要完善和打磨, 今天需要为所有的 TableView 列表页没有数据的时候展示一个友好的提示视图, 一个一个改太麻烦了. 而且业务逻辑烦杂改起来也不容易. 所以花了点时间写了一个小东西.在项目中按照项目的规范前缀使用了<code>AN</code>, 自己提取出来还是按照自己的喜好将前缀改为了<code>XY</code>.</p><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p><a href="https://github.com/hanyx1992/XYTableViewNoDataView" target="_blank" rel="noopener">国际惯例, 先上 Demo</a><br><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604db054a370ab5?w=480&amp;h=921&amp;f=gif&amp;s=341232" alt="Demo效果"></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>拖拽即可使用, 无需 import , 对原有代码无需进行任何修改</li><li>也可以选择实现方法, 实现快捷的自定义和完全的自定义</li></ul><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p>今天搜索到了这篇文章, 也是我的思路来源.<br><a href="http://www.jianshu.com/p/e39699b0d134" target="_blank" rel="noopener">UITableView没数据时用户提示如何做</a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="无入侵"><a href="#无入侵" class="headerlink" title="无入侵"></a>无入侵</h3><p>使用 Runtime 交换方法实现对原有代码无入侵.<br>创建一个 TableView 的分类, 在 .m 中</p><pre><code class="objc">#import &lt;objc/runtime.h&gt;</code></pre><p>目前我想到的思路是在 <code>reloadData</code> 的时候进行实现, 所以定义一个<br><code>xy_reloadData</code> 方法, 然后和原有的 <code>reloadData</code> 方法进行交换. </p><p>也就是说:</p><ul><li>在代码中所有调用 <code>reloadData</code> 的方法最终会调用我们自定义的 <code>xy_reloadData</code> 方法.</li><li>我们 <code>xy_reloadData</code> 方法中, 如果想调用系统的 <code>reloadData</code> 方法, 则需要调用 <code>xy_reloadData</code> 方法.</li></ul><pre><code class="objc">+ (void)load {    Method reloadData    = class_getInstanceMethod(self, @selector(reloadData));    Method xy_reloadData = class_getInstanceMethod(self, @selector(xy_reloadData));    method_exchangeImplementations(reloadData, xy_reloadData);}</code></pre><p>对 load 方法的描述是</p><blockquote><p>Invoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading.<br>当一个 <strong>类</strong> 或 <strong>分类</strong> 添加到 <strong>Objective-C Runtime</strong> 时；实现这个方法来加载后执行特定类的行为。</p></blockquote><p>所以可以实现无需 import 就可以实现加载.</p><h3 id="获取-TableView-的数据量"><a href="#获取-TableView-的数据量" class="headerlink" title="获取 TableView 的数据量"></a>获取 TableView 的数据量</h3><p>TableView 有可能有多个 Sections 每个 Section 都有可能有很多 Cell. 所以不能单单判断第一个 Section 是否有数据. 所以要:</p><ul><li>获取 Section 的数量</li><li>获取每一个 Section 当中 Cell 的数量</li></ul><pre><code class="objc">    NSInteger numberOfSections = [self numberOfSections];    BOOL havingData = NO;    for (NSInteger i = 0; i &lt; numberOfSections; i++) {        if ([self numberOfRowsInSection:i] &gt; 0) {            havingData = YES;            break;        }    }</code></pre><p>这样这个布尔值 havingData 即是是否有数据的标记.</p><h3 id="如何实现-reloadData-完成之后再获取数量"><a href="#如何实现-reloadData-完成之后再获取数量" class="headerlink" title="如何实现 reloadData 完成之后再获取数量."></a>如何实现 reloadData 完成之后再获取数量.</h3><p>因为 TableView 的 reloadData 方法具体实现是异步的.想要获取到加载完成的状态有两种方法</p><ol><li>使用 <code>layoutIfNeeded</code> 方法</li><li>获取<code>主队列</code>异步执行</li></ol><p>第一种方法实现代码为:</p><pre><code class="objc">    [self xy_reloadData];    [self layoutIfNeeded];    //接下来的代码</code></pre><p>这样的话线程会一直阻塞, 当然我们不希望<strong>原来业务代码中的 reloadData 会阻塞, 直到加载完成之后再继续执行代码</strong>.</p><p>所以我选择第二种方法</p><pre><code class="objc">    [self xy_reloadData];    dispatch_async(dispatch_get_main_queue(), ^{        //接下来的代码    });</code></pre><p>那么我们 <code>xy_reloadData</code> 中的方法实现为:</p><pre><code class="objc">- (void)xy_reloadData {    [self xy_reloadData];    //  刷新完成之后检测数据量    dispatch_async(dispatch_get_main_queue(), ^{        NSInteger numberOfSections = [self numberOfSections];        BOOL havingData = NO;        for (NSInteger i = 0; i &lt; numberOfSections; i++) {            if ([self numberOfRowsInSection:i] &gt; 0) {                havingData = YES;                break;            }        }        [self xy_havingData:havingData];    });}</code></pre><h3 id="展示一个占位视图"><a href="#展示一个占位视图" class="headerlink" title="展示一个占位视图"></a>展示一个占位视图</h3><p>TableView 有一个 backgroundView 的属性可以很好的胜任这个需求<br>可以根据 havingData 的状态来进行赋值</p><pre><code class="objc">- (void)xy_havingData:(BOOL)havingData {    if (havingData) {        self.backgroundView = nil;    } else {        self.backgroundView = 自定义视图;    }}</code></pre><h3 id="如何让控制器自定义视图"><a href="#如何让控制器自定义视图" class="headerlink" title="如何让控制器自定义视图"></a>如何让控制器自定义视图</h3><p>当然我们不满足于简简单单的视图的需求, 我们希望对应的控制器可以根据自己的需求自定义自己的视图.</p><p>我们最习惯的方法当然是在 TableView 的代理类(通常是控制器)中去处理 TableView 的一些逻辑</p><p>那么假设我们希望代理类实现一个方法 <code>xy_noDataView</code></p><pre><code class="objc">    if ([self.delegate respondsToSelector:@selector(xy_noDataView)]) {        self.backgroundView = [self.delegate performSelector:@selector(xy_noDataView)];        return ;    }</code></pre><p>这个地方会有一个编译警告, 我选择在 .m 文件中定义一个 protocol 来消除, 我还定义了一些其他的方法来更好的完成我的需求.</p><pre><code class="objc">/** 消除警告 */@protocol XYTableViewDelegate &lt;NSObject&gt;@optional- (UIView   *)xy_noDataView;                //  完全自定义占位图- (UIImage  *)xy_noDataViewImage;           //  使用默认占位图, 提供一张图片,    可不提供, 默认不显示- (NSString *)xy_noDataViewMessage;         //  使用默认占位图, 提供显示文字,    可不提供, 默认为暂无数据- (UIColor  *)xy_noDataViewMessageColor;    //  使用默认占位图, 提供显示文字颜色, 可不提供, 默认为灰色- (NSNumber *)xy_noDataViewCenterYOffset;   //  使用默认占位图, CenterY 向下的偏移量@end</code></pre><p>之所以没有在. h 中声明, 然后要求控制器实现我们的代理, 然后在去实现方法是想尽可能的无侵入, 契约式编程, 按规则实现方法既可以生效.</p><p>我希望能实现 <strong>拖来即用, 想扔就扔</strong></p><p>我还实现了一些简单的功能. 详细的可以查看 Demo.</p><p>完整的<code>xy_havingData</code>方法如下:</p><pre><code class="objc">- (void)xy_havingData:(BOOL)havingData {    //  不需要显示占位图    if (havingData) {        self.backgroundView = nil;        return ;    }    //  不需要重复创建    if (self.backgroundView) {        return ;    }    //  自定义了占位图    if ([self.delegate respondsToSelector:@selector(xy_noDataView)]) {        self.backgroundView = [self.delegate performSelector:@selector(xy_noDataView)];        return ;    }    //  使用自带的    UIImage  *img   = nil;    NSString *msg   = @&quot;暂无数据&quot;;    UIColor  *color = [UIColor lightGrayColor];    CGFloat  offset = 0;    //  获取图片    if ([self.delegate    respondsToSelector:@selector(xy_noDataViewImage)]) {        img = [self.delegate performSelector:@selector(xy_noDataViewImage)];    }    //  获取文字    if ([self.delegate    respondsToSelector:@selector(xy_noDataViewMessage)]) {        msg = [self.delegate performSelector:@selector(xy_noDataViewMessage)];    }    //  获取颜色    if ([self.delegate      respondsToSelector:@selector(xy_noDataViewMessageColor)]) {        color = [self.delegate performSelector:@selector(xy_noDataViewMessageColor)];    }    //  获取偏移量    if ([self.delegate        respondsToSelector:@selector(xy_noDataViewCenterYOffset)]) {        offset = [[self.delegate performSelector:@selector(xy_noDataViewCenterYOffset)] floatValue];    }    //  创建占位图    self.backgroundView = [self xy_defaultNoDataViewWithImage  :img message:msg color:color offsetY:offset];}</code></pre><p>实现了, 可以通过完全自定义 View 的方法实现完全自定义, 也可以使用自带的一些样式, 指定<strong>图片</strong>, <strong>文字</strong>, <strong>文字颜色</strong>, 以及<strong>位置偏移量</strong>, 当然<strong>其中任何一个都是可以不指定的, 使用默认设定</strong>.</p><p>界面的一些代码</p><pre><code class="objc">/** 默认的占位图 */- (UIView *)xy_defaultNoDataViewWithImage:(UIImage *)image message:(NSString *)message color:(UIColor *)color offsetY:(CGFloat)offset {    //  计算位置, 垂直居中, 图片默认中心偏上.    CGFloat sW = self.bounds.size.width;    CGFloat cX = sW / 2;    CGFloat cY = self.bounds.size.height * (1 - 0.618) + offset;    CGFloat iW = image.size.width;    CGFloat iH = image.size.height;    //  图片    UIImageView *imgView = [[UIImageView alloc] init];    imgView.frame        = CGRectMake(cX - iW / 2, cY - iH / 2, iW, iH);    imgView.image        = image;    //  文字    UILabel *label       = [[UILabel alloc] init];    label.font           = [UIFont systemFontOfSize:17];    label.textColor      = color;    label.text           = message;    label.textAlignment  = NSTextAlignmentCenter;    label.frame          = CGRectMake(0, CGRectGetMaxY(imgView.frame) + 24, sW, label.font.lineHeight);    //  视图    XYNoDataView *view   = [[XYNoDataView alloc] init];    [view addSubview:imgView];    [view addSubview:label];    //  实现跟随 TableView 滚动    [view addObserver:self forKeyPath:kXYNoDataViewObserveKeyPath options:NSKeyValueObservingOptionNew context:nil];    return view;}</code></pre><h3 id="细节优化"><a href="#细节优化" class="headerlink" title="细节优化"></a>细节优化</h3><h4 id="如何实现页面加载的时候不展示占位图"><a href="#如何实现页面加载的时候不展示占位图" class="headerlink" title="如何实现页面加载的时候不展示占位图"></a>如何实现页面加载的时候不展示占位图</h4><p>在 TableView 显示到界面上时, 相当于调用了 <code>reloadData</code> 方法, 所以按照我们目前的逻辑会先展示一个占位图, 然后数据加载完成后, 再次调用 <code>reloadData</code> 方法以隐藏占位图. </p><p>数据加载之前, 我们肯定不希望展示无数据的占位图, 因为很有可能是有数据的, 所以可以忽略掉第一次调用 <code>reloadData</code> 的处理, 在 <code>xy_reloadData</code> 方法中增加如下校验在 <code>[self xy_reloadData];</code> 之后, 如果没有加载完成数据时, 我们默认当做有数据去处理, 即相当于占位图不显示. 然后记录一下, 数据已经加载完成了. </p><pre><code class="objc">    //  忽略第一次加载    if (![self isInitFinish]) {        [self xy_havingData:YES];        [self setIsInitFinish:YES];        return ;    }</code></pre><p>为 TableView 绑定一个属性用来记录是否已经加载完</p><pre><code class="objc">/** 设置已经加载完成数据了 */- (void)setIsInitFinish:(BOOL)finish {    objc_setAssociatedObject(self, @selector(isInitFinish), @(finish), OBJC_ASSOCIATION_RETAIN_NONATOMIC);}/** 是否已经加载完成数据 */- (BOOL)isInitFinish {    id obj = objc_getAssociatedObject(self, _cmd);    return [obj boolValue];}</code></pre><h4 id="滚动时如何让占位图跟随-TableView-的滚动而滚动"><a href="#滚动时如何让占位图跟随-TableView-的滚动而滚动" class="headerlink" title="滚动时如何让占位图跟随 TableView 的滚动而滚动."></a>滚动时如何让占位图跟随 TableView 的滚动而滚动.</h4><p>因为我们的占位图是赋值在 TableView 的 <code>backgroundView</code> 属性上的, 相当于增加到了 TableView 上, 通过调试可以发现, 在 TableView 滚动 <code>contentOffset</code> 改变时, <code>backgroundView</code> 的<code>frame.origin.y</code>也是同步改变的, 所以我们看起来无论 TableView 怎么滚动占位图都是无动于衷的, 如果我们想让占位图跟随滚动的话, 只要取消掉<code>backgroundView</code> 的 <code>frame.origin.y</code> 的同步更新就好了, <strong>也就是说要保证 <code>frame.origin.y</code> 的值一直为0.</strong></p><p>我这里没有找到更好的办法, 暂时使用 KVO 来实现, 记得 View 销毁的时候要移除 KVO 的监听, 详细实现可以看 Demo 啦…</p><pre><code class="objc">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context {    if ([keyPath isEqualToString:kXYNoDataViewObserveKeyPath]) {        /**         在 TableView 滚动 ContentOffset 改变时, 会同步改变 backgroundView 的 frame.origin.y         可以实现, backgroundView 位置相对于 TableView 不动, 但是我们希望         backgroundView 跟随 TableView 的滚动而滚动, 只能强制设置 frame.origin.y 永远为 0         兼容 MJRefresh         */        CGRect frame = [[change objectForKey:NSKeyValueChangeNewKey] CGRectValue];        if (frame.origin.y != 0) {            frame.origin.y  = 0;            self.backgroundView.frame = frame;        }    }}</code></pre><h3 id="如果不想显示占位图怎么办"><a href="#如果不想显示占位图怎么办" class="headerlink" title="如果不想显示占位图怎么办?"></a>如果不想显示占位图怎么办?</h3><p>在对应的控制器实现如下方法即可</p><pre><code class="obj">- (NSString *)xy_noDataViewMessage {    return @&quot;&quot;;}</code></pre><h3 id="关于分割线"><a href="#关于分割线" class="headerlink" title="关于分割线"></a>关于分割线</h3><p>在我上面提到的那篇文章中. 在修改 backgroundView 属性的同时修改了 TableView 的 <code>separatorStyle</code> 属性, 没数据的时候将分割线取消掉, 有数据的时候在添加上, 可是我在项目中使用的 TableView 的分割线 separatorStyle 风格不一. 所以我没有修改分割线属性, 如果想让 TableView 没有数据的时候隐藏分割线, 可以看我的 Demo 在对应的控制器添加这样一行代码即可.</p><pre><code class="objc">    self.tableView.tableFooterView = [UIView new];</code></pre><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>CollectionView 同理, 代码复制一遍, 将获取数据量的地方, 获取每个 Section 中 Cell 的数量的 <code>numberOfRowsInSection</code> 方法改为 <code>numberOfItemsInSection</code> 即可使用.</p><p>菜鸟一枚, 如果有大神不吝赐教, 必将感激不尽.</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>浅析 Qt 布局系统</title>
      <link href="/2017/12/13/qt-layout/"/>
      <url>/2017/12/13/qt-layout/</url>
      <content type="html"><![CDATA[<h2 id="Qt-布局系统介绍"><a href="#Qt-布局系统介绍" class="headerlink" title="Qt 布局系统介绍"></a>Qt 布局系统介绍</h2><h3 id="布局系统"><a href="#布局系统" class="headerlink" title="布局系统"></a>布局系统</h3><p>作为一名 iOS 开发人员, 见证着 iOS 布局系统的不断完善, 从绝对布局, Autoresizing 到 Autolayout. 使得开发人员的工作效率越来越高, 项目界面的可读性和易维护性越来越强. 如今 IDE 中的可视化界面工具已经非常强大, 许多网友”戏称” iOS 开发者为”UI 拖拽师”, 可见, iOS 开发中界面布局系统的高效. 所以, 优秀的布局系统的使命在于让开发者花更少的时间来完成更易维护的界面. </p><p>同样的, 在 Qt 中, 系统提供了强大的排版机制来为窗口中的视图进行布局排版, 经过了对 Qt 布局一个初步的探索, 不得不对 Qt 布局系统的简洁高效而又功能强大表示赞叹. </p><h4 id="布局系统的功能"><a href="#布局系统的功能" class="headerlink" title="布局系统的功能"></a>布局系统的功能</h4><p>在 Qt 中, 布局系统可以完成</p><ul><li>定位子控件</li><li>得知窗体默认大小</li><li>得知窗体最小大小</li><li>窗体大小变化时进行布局排版</li><li>内容改变(字体大小文本等, 隐藏或显示, 移除)时进行布局排版</li></ul><h4 id="布局系统的结构"><a href="#布局系统的结构" class="headerlink" title="布局系统的结构"></a>布局系统的结构</h4><p>Qt 提供了 QLayout 类及其子类来为界面进行排版布局. 结构如下图:</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604db4742693550?w=640&amp;h=360&amp;f=png&amp;s=22386" alt="布局系统结构图"></p><p> QLayout 是布局系统中的抽象基类, 继承自 QObject 和 QLayoutItem, 其中四个子类分别为</p><ul><li>QBoxLayout(箱式布局)</li><li>QFormLayout(表单布局)</li><li>QGridLayout(网格布局)</li><li>QStackedLayout(栈布局)</li></ul><p>在真实使用场景中, 往往需要通过多种布局的相结合来完成界面的设计, 接下来将分别介绍四中布局.</p><h4 id="QBoxLayout-箱式布局"><a href="#QBoxLayout-箱式布局" class="headerlink" title="QBoxLayout 箱式布局"></a>QBoxLayout 箱式布局</h4><p>箱式布局提供了两个子类分别处理水平(QHBoxLayout)和垂直(QVBoxLayout)两个方向的排版, 可以使视图排成一行或者一列来显示. 简单说, 就是可以让控件进行排排站, 比如在我们的 AlphaBox 中, 顶部的头像, 姓名, 和刷新按钮排成了一排, 这就是水平箱式布局:</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604db47427c71e4?w=480&amp;h=260&amp;f=png&amp;s=27839" alt="什么叫排排站"></p><p>你以为我要讲一下这个东西如何实现? NO, 我偏偏要以垂直箱式布局为例, 用一个最简单的例子来介绍箱式布局的使用, 首先创建一个基于 QWidget 的界面, 添加我们需要使用的头文件:</p><pre><code class="cpp">#include &lt;QVBoxLayout&gt;#include &lt;QPushButton&gt;</code></pre><p>并在构造函数中添加如下代码</p><pre><code class="cpp">    //  添加两个按钮    QPushButton *okBtn  = new QPushButton;    okBtn -&gt;setText(tr(&quot;我在上面, 我最牛&quot;));    QPushButton *celBtn = new QPushButton;    celBtn-&gt;setText(tr(&quot;我在下面, 我不服&quot;));    //  创建一个垂直箱式布局, 将两个按钮扔进去    QVBoxLayout *layout = new QVBoxLayout;    layout-&gt;addWidget(okBtn);    layout-&gt;addWidget(celBtn);    //  设置界面的布局为垂直箱式布局    setLayout(layout);</code></pre><p>运行看一下效果, 什么? 这就可以运行了? 坐标呢? 尺寸呢? 是的, 没看错…点击运行:</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604db4742a9c721?w=480&amp;h=268&amp;f=png&amp;s=30417" alt="最简单的箱式布局"></p><p>两个按钮已经一上一下, 乖乖的在垂直方向自己站好了位置, 就是这么强大, 就是这么省心.</p><h4 id="QFormLayout-表单布局"><a href="#QFormLayout-表单布局" class="headerlink" title="QFormLayout 表单布局"></a>QFormLayout 表单布局</h4><p>强大的 AlphaBox 是很外向的, 可以很轻松的将你的资料分享给其他用户, 当我们分享的时候, 会有这样一个界面:</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604db474299f9a3?w=480&amp;h=232&amp;f=png&amp;s=20804" alt="在 AlphaBox 中共享资料"></p><p>看到这个界面, 聪明的你可能会说, 这很简单啊, 好几个水平箱式布局就可以实现, 可是, 更聪明的 Qt 提供了更高效的方式帮助你完成这样一个界面, 那就是 QFormLayout.</p><p>在我所学习 Qt 所使用的书籍中, 将 QFormLayout 翻译为窗体布局, 我个人认为, 将其翻译为表单布局更为贴切, 因为 QFormLayout 的强大之处正是可以使用最快的速度完成一个用户输入的表单界面的搭建.</p><p>那么, 让我们揭开 AlphaBox 的神秘面纱, 看看这样一个界面是怎么实现的.</p><p>首先, 拖拽一个 Form Layout 到 Widget 中.</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604db474545565c?w=480&amp;h=205&amp;f=jpeg&amp;s=11896" alt="添加表单布局"></p><p>双击之后即可为表单增加一行.</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604db4745517544?w=480&amp;h=478&amp;f=png&amp;s=50895" alt="为表单增加一行"></p><p>相信大家看到这张图时, 就已经能理解到表单布局是如何使用的, 提供了标签作为用户输入内容的指引, 提供字段类型作为用户输入的控件, 作为 iOS 开发者, 深知这样一个界面的搭建所需要的繁杂的工作量. 当我第一次打开这个界面时, 被这样创建界面的方式所惊呆了. </p><ol><li>按照图中, 创建表单的第一行, 共享给哪个用户的输入框, 可以为输入框填写占位文字.</li><li>双击 Form Layout 创建字段类型为 QComboBox (多选框)的一行. 填写允许的权限内容.</li><li>设置整个 Widget 布局为垂直箱式布局</li><li>在 Form Layout 下拖拽过去一个 Horizontal Layout(水平箱式布局)</li><li>在箱式布局中添加 Horizontal Spacer (水平占位) 后拖拽两个 Push Button 完成界面布局</li></ol><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604db47738ff342?w=480&amp;h=165&amp;f=jpeg&amp;s=12866" alt="共享界面的布局"></p><p>快不快? 快不快! 快不快!!!</p><p>同样的, 如果是使用纯代码表单布局的话可以使用<code>addRow()</code>的方法来添加一行.</p><h4 id="QGridLayout-网格布局"><a href="#QGridLayout-网格布局" class="headerlink" title="QGridLayout 网格布局"></a>QGridLayout 网格布局</h4><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604db477397fa8f?w=480&amp;h=349&amp;f=png&amp;s=20575" alt="强大的 AlphaBox 是这样的"></p><p>事实上, 强大的 AlphaBox 是这样的, 我们可以共享给多个用户, 而且, 下方会有一个列表, 展示共享的用户以及权限列表. 这时, 表单布局就没办法满足我们, 只好另求新欢 QGridLayout - 网格布局.</p><p>网格布局顾名思义, 可以将界面分割成行列来进行布局管理, 在每个单元格中来摆放控件. 所以 AlphaBox 分享的界面使用了一个 <strong>两行三列</strong> 的网格布局来实现的.</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604db4778649978?w=480&amp;h=85&amp;f=jpeg&amp;s=7669" alt="QGridLayout - 网格布局"></p><p>当然, 更更复杂的界面, 用 Qt 布局的效率也是非常高的, 我做了一个外链分享的布局 Demo, 可以将内部资料生成一个下载链接共享给任何人去下载.</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604db47787dc959?w=480&amp;h=357&amp;f=png&amp;s=31610" alt="外链分享界面"></p><p>这个界面中, 我在Tab之内使用了网格布局, 布局如图:</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604db477dd43f8c?w=480&amp;h=320&amp;f=jpeg&amp;s=19381" alt="外链分享界面布局"></p><p>从图中可以看出, 网格布局像是在操作一个 Excel 一样简单, 布局单元格, 合并单元格, 等等.</p><p>在这个界面中, 更灵活的使用了 QLayout 的属性来完成了界面布局排版.</p><p>同样的, 在代码中, 可以使用如下等的 Api 来为网格视图添加一个从几行几列开始占据几行几列的控件:</p><pre><code class="cpp">void addWidget(QWidget *, int row, int column, int rowSpan, int columnSpan)</code></pre><h4 id="QStackedLayout-栈布局"><a href="#QStackedLayout-栈布局" class="headerlink" title="QStackedLayout 栈布局"></a>QStackedLayout 栈布局</h4><p>如在 AlphaBox 中, 我们可以通过云端文件浏览器直接查看和操作云端文件, 在加载的过程中, 会有一个转菊花的界面.</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604db478e91a5a1?w=480&amp;h=377&amp;f=png&amp;s=12861" alt="在转菊花的 AlphaBox"></p><p>加载失败时的错误提示:</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604db4794309c91?w=480&amp;h=377&amp;f=png&amp;s=15651" alt="菊花转失败了的 AlphaBox"></p><p>以及加载成功时:</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604db4799cf96cf?w=480&amp;h=377&amp;f=png&amp;s=25245" alt="通常情况下我们能看见的 AlphaBox"></p><p>通常应用的界面会根据不同的状态有不同的内容, 这时就可以使用 QStackedLayout 栈布局, 栈布局提供了一个页面的栈, 每个页面有完全独立的界面布局. 可以非常清晰的对不同状态下的界面进行布局管理.</p><p>在 Qt 的可视化布局工具中, 通过 Stacked Widget 来完成界面的栈布局</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604db479df25bf5?w=320&amp;h=289&amp;f=jpeg&amp;s=12895" alt="Stacked Widget"></p><p>通过右键来进行页面的插入移除和排序等操作.</p><h3 id="布局相关属性"><a href="#布局相关属性" class="headerlink" title="布局相关属性"></a>布局相关属性</h3><h4 id="控件大小"><a href="#控件大小" class="headerlink" title="控件大小"></a>控件大小</h4><p>对于控件大小, 最重要的两个属性是 <code>sizeHint</code> 和 <code>minimumSizeHint</code> , 这是 QWidget 的属性, 是只读属性. 其中, <code>sizeHint</code> 属性为控件的建议大小, 对于不同的控件, 有不同的建议大小, 同理 <code>minimumSizeHint</code> 为建议的最小大小. 知道了这两个属性才可以理解布局中控件的大小是如何控制的. 如果手动设置了最小尺寸的话(<code>minimumSize</code>), <code>minimumSizeHint</code> 是会被忽略的.</p><h4 id="大小策略"><a href="#大小策略" class="headerlink" title="大小策略"></a>大小策略</h4><p>大小策略属性 <code>sizePolicy</code> 也是 QWidget 类的属性, 这个属性在水平和垂直两个方向分别起作用, 控制着控件大小变化的策略.</p><p>在可视化工具中可以直观的看到几种大小策略, 以垂直为例如图:</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604db479dd52506?w=530&amp;h=292&amp;f=jpeg&amp;s=23280" alt="大小策略"></p><ul><li><code>QSizePolicy::Fixed</code> 只能使用 sizeHint 的大小, 任何操作都不会改变控件大小</li><li><code>QSizePolicy::Minimum</code> sizeHint 为最小大小, 控件可以被拉伸</li><li><code>QSizePolicy::Maximum</code> sizeHint 为最大大小, 控件可以被压缩</li><li><code>QSizePolicy::Preferred</code> sizeHint 为建议大小, 控件既可以被压缩也可以被拉伸</li><li><code>QSizePolicy::MinimumExpanding</code> sizeHint 为最小大小, 不能被压缩, 被拉伸的优先级更高</li><li><code>QSizePolicy::Expanding</code> sizeHint 为建议大小, 可以被压缩, 被拉伸的优先级更高</li><li><code>QSizePolicy::Ignored</code> sizeHint 的值将会被忽略</li></ul><p>在网上或者书中, 关于这些策略的说明会有很多, 可是如果不是真的自己尝试一下, 很难很好的理解在复杂布局的情况下, 大小策略是如何控制布局的, 尤其是 <code>MinimumExpanding</code>, <code>Expanding</code>, <code>Ignored</code> 这三种. </p><p>对于优先级的概念大家肯定不会陌生, 这里我认为优先级来解释这些策略是更清晰易懂的.</p><p>关于<strong>拉伸</strong> <code>Expanding</code> , <code>MinimumExpanding</code> 优先级相同, 同时要比 <code>Preferred</code> 和 <code>Ignored</code> 拉伸优先级更高, <code>Preferred</code> 和 <code>Ignored</code> 相同.</p><p> 换句话说, 如果两个控件在一个水平箱式布局中管理, 其中一个水平大小策略为 <code>Preferred</code> 另一个为 <code>Expanding</code> 或者 <code>MinimumExpanding</code> 如果水平拉伸窗体, 则 <code>Preferred</code>的控件大小不会改变, <code>Expanding</code> 或者是 <code>MinimumExpanding</code> 会被拉伸.</p><p>同理, 如果两个控件水平大小策略一个为<code>Expanding</code>, 一个是<code>MinimumExpanding</code>, 这时拉伸窗体, 则两个控件均会拉伸.</p><p>多说一句, 如果两个控件都为 <code>Fixed</code> 无法拉伸时, 控件间的间隙会被拉伸.</p><p>关于<strong>压缩</strong> 如果达到了<code>minimumSizeHint</code>是不会被继续压缩了, 但是<code>Ignored</code>是会忽略 <code>sizeHint</code> 和 <code>minimumSizeHint</code> 的属性的, 所以是会继续被压缩的.</p><h4 id="伸缩性"><a href="#伸缩性" class="headerlink" title="伸缩性"></a>伸缩性</h4><p>在 QLayout 中提供了一个和控件大小策略相关的属性, <code>layoutStretch</code> 布局伸缩性, 这个值是一个比例, 在可视化工具中可以更直观的看到这个值的设置, 如果在布局中有三个控件, 则是三个控件的占比, 用逗号分隔, 如: <code>1, 1, 1</code> .</p><p>伸缩性就好理解一些了, 但是要注意的是, 只有<strong>会被压缩或者拉伸</strong>的控件才会受该属性值影响(如 <code>Fixed</code> 是不会受该属性影响)</p><p> 还有一点非常重要的是设置了伸缩性的比值(如果都为0, 则表示不设置) 刚刚提到的<strong>大小策略的优先级将会被忽略</strong>, 还是刚刚的例子, 如果两个控件在一个水平箱式布局中管理, 其中一个水平大小策略为 <code>Preferred</code> 另一个为 <code>Expanding</code>, 设置水平箱式布局的 <code>layoutStretch</code> 为 <code>2, 1</code> 则拉伸时, 并不会像刚刚所说, 只有 <code>Expanding</code> 的控件会被拉伸, 而是都会被拉伸, 按照一个 2 : 1 的拉伸比例拉伸.</p><h4 id="窗体大小约束策略"><a href="#窗体大小约束策略" class="headerlink" title="窗体大小约束策略"></a>窗体大小约束策略</h4><p>最后想介绍一下 QLayout 的 <code>layoutSizeConstraint</code> 属性, 用来约束窗体大小,  只影响窗体, 所以<strong>该属性只对最顶级的 QLayout 起作用</strong>.</p><p> <img src="https://user-gold-cdn.xitu.io/2017/12/13/1604db479dfbd358?w=320&amp;h=678&amp;f=jpeg&amp;s=42338" alt="layoutSizeConstraint"></p><p>关于这几个属性同样的, 简单的介绍网上和书上会有很多, 如果不尝试一下, 浅显的字面意思无法理解这几个属性的作用. 根据我的尝试, 总结如下:</p><ul><li><code>QLayout::SetDefaultConstraint</code> 窗体最小值被设置为 minimumSize 值无法再缩小, <strong>如果 QLayout 内控件有更大的minimumSize, 则会取更大的minimumSize.</strong></li><li><code>QLayout::SetNoConstraint</code> 窗体没有约束策略</li><li><code>QLayout::SetFixedSize</code>，窗体大小被设定为 sizeHint 的大小，无法改变</li><li><code>QLayout::SetMinimumSize</code> 窗体最小为 minimumSize 无法再缩小, <strong>如果 QLayout 内控件有更小的minimumSize, 则会取更小的minimumSize.</strong>, 总结就是的话, 和 Default 不同的地方就是尽可能的小.</li><li><code>QLayout::SetMaxmumSize</code> 同理, 窗体最大值为 maxmumSize , 无法再放大</li><li><code>QLayout::SetMinAndMaxSize</code> 窗体最小为 minimumSize 无法再缩小, 窗体最大值为 maxmumSize , 无法再放大</li></ul><h4 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h4><p>关于表单布局和网格布局还有其他的属性约束单元格的一些策略, 如 <code>layoutFieldGrowthPolicy</code> 控件的变化方式策略等等有兴趣可以查看官方文档, 更多的属性间隙, 间隔, 对其方式等等都比较好理解了, 在此也不赘述了.</p><h4 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h4><p><a href="http://doc.qt.io" target="_blank" rel="noopener"> Qt 官方文档点这里</a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote><p>&lt;&lt; Qt Creator 快速入门&gt;&gt; 第三版, 霍亚飞著</p></blockquote>]]></content>
      
      
    </entry>
    
  
  
</search>
